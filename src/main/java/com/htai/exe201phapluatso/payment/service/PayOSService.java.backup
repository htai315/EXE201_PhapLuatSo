package com.htai.exe201phapluatso.payment.service;

import com.htai.exe201phapluatso.auth.entity.Plan;
import com.htai.exe201phapluatso.auth.entity.User;
import com.htai.exe201phapluatso.auth.repo.PlanRepo;
import com.htai.exe201phapluatso.auth.repo.UserRepo;
import com.htai.exe201phapluatso.common.exception.BadRequestException;
import com.htai.exe201phapluatso.common.exception.ForbiddenException;
import com.htai.exe201phapluatso.common.exception.NotFoundException;
import com.htai.exe201phapluatso.credit.service.CreditService;
import com.htai.exe201phapluatso.payment.dto.CreatePaymentResponse;
import com.htai.exe201phapluatso.payment.dto.PaymentHistoryResponse;
import com.htai.exe201phapluatso.payment.entity.Payment;
import com.htai.exe201phapluatso.payment.repo.PaymentRepo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import vn.payos.PayOS;
import vn.payos.model.v2.paymentRequests.CreatePaymentLinkRequest;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

@Service
public class PayOSService {

    private static final Logger log = LoggerFactory.getLogger(PayOSService.class);

    private final PayOS payOS;
    private final PaymentRepo paymentRepo;
    private final UserRepo userRepo;
    private final PlanRepo planRepo;
    private final CreditService creditService;

    private final AtomicLong orderCodeCounter = new AtomicLong(System.currentTimeMillis() % 1000000);

    @Value("${payos.return-url}")
    private String returnUrl;

    @Value("${payos.cancel-url}")
    private String cancelUrl;

    @Value("${payment.spam-block-minutes:10}")
    private int spamBlockMinutes;

    @Value("${payment.stale-payment-minutes:30}")
    private int stalePaymentMinutes;

    @Value("${payment.max-cleanup-batch-size:20}")
    private int maxCleanupBatchSize;

    @Value("${payment.max-retries:3}")
    private int maxRetries;

    @Value("${payment.retry-base-delay-ms:500}")
    private long retryBaseDelayMs;

    @Value("${payment.test-mode:false}")
    private boolean testMode;

    @Value("${payment.reuse-pending-payment:true}")
    private boolean reusePendingPayment;

    public PayOSService(
            PayOS payOS,
            PaymentRepo paymentRepo,
            UserRepo userRepo,
            PlanRepo planRepo,
            CreditService creditService
    ) {
        this.payOS = payOS;
        this.paymentRepo = paymentRepo;
        this.userRepo = userRepo;
        this.planRepo = planRepo;
        this.creditService = creditService;
    }

    @Transactional
    public CreatePaymentResponse createPayment(Long userId, String planCode) {
        if (planCode == null || planCode.isBlank()) {
            throw new BadRequestException("Mã gói không được để trống");
        }

        User user = userRepo.findById(userId)
                .orElseThrow(() -> new NotFoundException("Không tìm thấy người dùng"));

        Plan plan = planRepo.findByCode(planCode)
                .orElseThrow(() -> new NotFoundException("Không tìm thấy gói: " + planCode));

        // Eagerly load plan data to avoid LazyInitializationException
        String planName = plan.getName();
        int planPrice = plan.getPrice();
        int chatCredits = plan.getChatCredits();
        int quizGenCredits = plan.getQuizGenCredits();
        int durationMonths = plan.getDurationMonths();

        if (planPrice <= 0) {
            throw new BadRequestException("Gói không hợp lệ");
        }

        // Check for existing pending payment
        List<Payment> pendingPayments = paymentRepo.findByUserAndStatusOrderByCreatedAtDesc(user, "PENDING");
        
        if (!pendingPayments.isEmpty()) {
            Payment latestPending = pendingPayments.get(0);
            
            // Nếu có pending payment cùng gói
            if (latestPending.getPlan().getCode().equals(planCode)) {
                LocalDateTime createdAt = latestPending.getCreatedAt();
                boolean isRecent = createdAt.isAfter(LocalDateTime.now().minusMinutes(spamBlockMinutes));
                
                // REUSE LOGIC: Trả về payment link cũ nếu còn mới
                if (reusePendingPayment && isRecent) {
                    log.info("REUSING existing pending payment: orderCode={}, user={}, plan={}", 
                            latestPending.getOrderCode(), userId, planCode);
                    
                    try {
                        // Lấy payment link từ PayOS
                        var paymentInfo = payOS.paymentRequests().get(latestPending.getOrderCode());
                        
                        // Kiểm tra status
                        String statusName = paymentInfo.getStatus() != null ? paymentInfo.getStatus().name() : null;
                        
                        if ("PENDING".equals(statusName) || "PROCESSING".equals(statusName)) {
                            // Payment link vẫn còn active, reuse nó
                            // PaymentLink không có getCheckoutUrl(), chỉ có getCheckoutUrl từ CreatePaymentLinkResponse
                            // Nên ta phải tạo lại URL từ paymentLinkId
                            String checkoutUrl = "https://pay.payos.vn/web/" + paymentInfo.getPaymentLinkId();
                            log.info("Payment link still active, reusing: {}", checkoutUrl);
                            
                            return new CreatePaymentResponse(
                                    checkoutUrl,
                                    String.valueOf(latestPending.getOrderCode()),
                                    null, // QR code không có trong PaymentLink response
                                    (long) planPrice,
                                    planName
                            );
                        } else if ("CANCELLED".equals(statusName) || "EXPIRED".equals(statusName)) {
                            // Payment đã hết hạn, update status và tạo mới
                            log.info("Payment link expired/cancelled, creating new one");
                            latestPending.setStatus("EXPIRED");
                            paymentRepo.save(latestPending);
                            // Continue to create new payment below
                        } else if ("PAID".equals(statusName)) {
                            // Đã thanh toán nhưng webhook chưa xử lý
                            log.warn("Payment already PAID but webhook not processed: {}", latestPending.getOrderCode());
                            latestPending.setStatus("NEEDS_REVIEW");
                            paymentRepo.save(latestPending);
                            // Continue to create new payment below
                        }
                        
                    } catch (Exception e) {
                        // Không lấy được payment info từ PayOS (có thể do credentials sai, hoặc payment không tồn tại)
                        log.warn("Cannot get payment info from PayOS: {}", e.getMessage());
                        
                        // Nếu trong test mode, skip và tạo mới
                        if (testMode) {
                            log.warn("TEST MODE: Skipping reuse check, will create new payment");
                        } else {
                            // Production: block spam
                            throw new BadRequestException(
                                "Bạn đã có giao dịch đang chờ xử lý cho gói này. " +
                                "Vui lòng hoàn tất thanh toán hoặc đợi " + spamBlockMinutes + " phút để tạo đơn mới."
                            );
                        }
                    }
                            // Continue to create new payment below
                        } else if ("PAID".equals(statusName)) {
                            // Đã thanh toán nhưng webhook chưa xử lý
                            log.warn("Payment already PAID but webhook not processed: {}", latestPending.getOrderCode());
                            latestPending.setStatus("NEEDS_REVIEW");
                            paymentRepo.save(latestPending);
                            // Continue to create new payment below
                        }
                        
                    } catch (Exception e) {
                        // Không lấy được payment info từ PayOS (có thể do credentials sai, hoặc payment không tồn tại)
                        log.warn("Cannot get payment info from PayOS: {}", e.getMessage());
                        
                        // Nếu trong test mode, skip và tạo mới
                        if (testMode) {
                            log.warn("TEST MODE: Skipping reuse check, will create new payment");
                        } else {
                            // Production: block spam
                            throw new BadRequestException(
                                "Bạn đã có giao dịch đang chờ xử lý cho gói này. " +
                                "Vui lòng hoàn tất thanh toán hoặc đợi " + spamBlockMinutes + " phút để tạo đơn mới."
                            );
                        }
                    }
                } else if (!testMode && isRecent) {
                    // Không reuse nhưng vẫn block spam
                    log.warn("User {} already has a pending payment for same plan: {}", userId, latestPending.getOrderCode());
                    throw new BadRequestException(
                        "Bạn đã có giao dịch đang chờ xử lý cho gói này. " +
                        "Vui lòng hoàn tất thanh toán hoặc đợi " + spamBlockMinutes + " phút để tạo đơn mới."
                    );
                }
            }
        }

        long orderCode = generateUniqueOrderCode();

        Payment payment = new Payment();
        payment.setUser(user);
        payment.setPlan(plan);
        payment.setAmount(BigDecimal.valueOf(planPrice));
        payment.setOrderCode(orderCode);
        payment.setVnpTxnRef("PAYOS_" + orderCode);
        payment.setStatus("PENDING");
        payment.setPaymentMethod("PAYOS");
        payment.setWebhookProcessed(false);
        paymentRepo.save(payment);

        log.info("Created payment: orderCode={}, user={}, plan={}, amount={}",
                orderCode, userId, planCode, planPrice);

        try {
            String description = "Don hang " + orderCode;
            
            log.info("========== CREATING PAYOS PAYMENT ==========");
            log.info("OrderCode: {}", orderCode);
            log.info("Amount: {}", planPrice);
            log.info("Description: {}", description);
            log.info("ReturnUrl: {}", returnUrl);
            log.info("CancelUrl: {}", cancelUrl);
            
            CreatePaymentLinkRequest request = CreatePaymentLinkRequest.builder()
                    .orderCode(orderCode)
                    .amount((long) planPrice)
                    .description(description)
                    .cancelUrl(cancelUrl)
                    .returnUrl(returnUrl)
                    .build();

            // Retry logic - configurable retries
            var paymentLink = callPayOSWithRetry(request, maxRetries);

            // Log full response for debugging
            log.info("PayOS Response: checkoutUrl={}, qrCode={}, paymentLinkId={}", 
                    paymentLink.getCheckoutUrl(), 
                    paymentLink.getQrCode(),
                    paymentLink.getPaymentLinkId());
            log.info("========== PAYOS PAYMENT CREATED ==========");

            // If no QR code from PayOS, generate VietQR URL
            String qrCode = paymentLink.getQrCode();
            if (qrCode == null || qrCode.isBlank()) {
                // PayOS may not return QR in some cases, use checkout URL as fallback
                log.info("No QR code from PayOS, using checkout URL");
            }

            return new CreatePaymentResponse(
                    paymentLink.getCheckoutUrl(),
                    String.valueOf(orderCode),
                    qrCode,
                    (long) planPrice,
                    planName
            );

        } catch (Exception e) {
            log.error("========== PAYOS PAYMENT FAILED ==========");
            log.error("Error class: {}", e.getClass().getName());
            log.error("Error message: {}", e.getMessage());
            log.error("Full stack trace:", e);
            payment.setStatus("FAILED");
            paymentRepo.save(payment);
            throw new BadRequestException("Không thể tạo link thanh toán: " + e.getMessage());
        }
    }

    /**
     * Call PayOS API with retry logic to handle intermittent failures
     */
    private vn.payos.model.v2.paymentRequests.CreatePaymentLinkResponse callPayOSWithRetry(
            CreatePaymentLinkRequest request, int maxRetries) throws Exception {
        Exception lastException = null;
        
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                log.info("Calling PayOS API... (attempt {}/{})", attempt, maxRetries);
                return payOS.paymentRequests().create(request);
            } catch (Exception e) {
                lastException = e;
                log.warn("PayOS API call failed (attempt {}/{}): {}", attempt, maxRetries, e.getMessage());
                
                // Don't retry on certain errors
                String errorMsg = e.getMessage() != null ? e.getMessage().toLowerCase() : "";
                if (errorMsg.contains("invalid") || errorMsg.contains("unauthorized") || 
                    errorMsg.contains("duplicate") || errorMsg.contains("already exists")) {
                    throw e; // Don't retry these errors
                }
                
                if (attempt < maxRetries) {
                    // Wait before retry (exponential backoff using configured base delay)
                    long waitTime = retryBaseDelayMs * (1L << (attempt - 1));
                    log.info("Waiting {}ms before retry...", waitTime);
                    Thread.sleep(waitTime);
                }
            }
        }
        
        throw lastException;
    }

    private long generateUniqueOrderCode() {
        long timestamp = System.currentTimeMillis() % 10000000L;
        long counter = orderCodeCounter.incrementAndGet() % 1000;
        long orderCode = timestamp * 1000 + counter;
        
        int attempts = 0;
        while (paymentRepo.findByOrderCode(orderCode).isPresent() && attempts < 10) {
            counter = orderCodeCounter.incrementAndGet() % 1000;
            orderCode = timestamp * 1000 + counter;
            attempts++;
        }
        
        if (attempts >= 10) {
            orderCode = System.currentTimeMillis() % 9007199254740991L;
        }
        
        return orderCode;
    }

    @Transactional
    public void handleWebhook(Map<String, Object> webhookData) {
        try {
            log.info("========== PayOS WEBHOOK START ==========");
            log.info("Webhook data: {}", webhookData);

            var verifiedData = payOS.webhooks().verify(webhookData);
            
            long orderCode = verifiedData.getOrderCode();
            String code = verifiedData.getCode();

            log.info("Verified webhook: orderCode={}, code={}", orderCode, code);

            Payment payment = paymentRepo.findByOrderCodeWithLock(orderCode)
                    .orElseThrow(() -> new NotFoundException("Payment not found: " + orderCode));

            if (payment.getWebhookProcessed() != null && payment.getWebhookProcessed()) {
                log.warn("Webhook already processed for orderCode: {}", orderCode);
                return;
            }

            if ("SUCCESS".equals(payment.getStatus()) || "FAILED".equals(payment.getStatus())) {
                log.warn("Payment already in final state: {} for orderCode: {}", payment.getStatus(), orderCode);
                payment.setWebhookProcessed(true);
                paymentRepo.save(payment);
                return;
            }

            if ("00".equals(code)) {
                Plan plan = payment.getPlan();
                LocalDateTime expiresAt = plan.getDurationMonths() > 0
                        ? LocalDateTime.now().plusMonths(plan.getDurationMonths())
                        : null;

                try {
                    creditService.addCredits(
                            payment.getUser().getId(),
                            plan.getChatCredits(),
                            plan.getQuizGenCredits(),
                            plan.getCode(),
                            expiresAt
                    );
                    log.info("Credits added successfully for orderCode: {}", orderCode);
                } catch (Exception e) {
                    log.error("Failed to add credits for orderCode: {}", orderCode, e);
                    payment.setStatus("FAILED");
                    payment.setWebhookProcessed(true);
                    paymentRepo.save(payment);
                    throw new BadRequestException("Failed to add credits: " + e.getMessage());
                }

                payment.setStatus("SUCCESS");
                payment.setPaidAt(LocalDateTime.now());
                payment.setTransactionId(verifiedData.getReference());
                payment.setWebhookProcessed(true);
                paymentRepo.save(payment);

                log.info("Payment SUCCESS: orderCode={}, credits added", orderCode);
            } else {
                payment.setStatus("FAILED");
                payment.setWebhookProcessed(true);
                paymentRepo.save(payment);
                log.warn("Payment FAILED: orderCode={}, code={}", orderCode, code);
            }

            log.info("========== PayOS WEBHOOK END ==========");

        } catch (NotFoundException e) {
            log.error("Payment not found in webhook", e);
            throw e;
        } catch (Exception e) {
            log.error("Webhook processing failed", e);
            throw new BadRequestException("Invalid webhook: " + e.getMessage());
        }
    }

    public boolean verifyWebhookSignature(Map<String, Object> webhookData) {
        try {
            payOS.webhooks().verify(webhookData);
            return true;
        } catch (Exception e) {
            log.error("Webhook signature verification failed", e);
            return false;
        }
    }

    @Transactional(readOnly = true)
    public Payment getPaymentByOrderCode(long orderCode) {
        return paymentRepo.findByOrderCode(orderCode)
                .orElseThrow(() -> new NotFoundException("Payment not found: " + orderCode));
    }

    /**
     * Get payment status details for polling endpoint
     * This method eagerly loads all needed data within transaction
     */
    @Transactional(readOnly = true)
    public Map<String, Object> getPaymentStatusDetails(long orderCode) {
        Payment payment = paymentRepo.findByOrderCode(orderCode)
                .orElseThrow(() -> new NotFoundException("Payment not found: " + orderCode));

        Map<String, Object> response = new java.util.HashMap<>();
        response.put("orderCode", orderCode);
        response.put("status", payment.getStatus());
        response.put("amount", payment.getAmount());
        
        Plan plan = payment.getPlan();
        if (plan != null) {
            response.put("planCode", plan.getCode());
            response.put("planName", plan.getName());
            
            if ("SUCCESS".equals(payment.getStatus())) {
                response.put("paidAt", payment.getPaidAt());
                response.put("chatCredits", plan.getChatCredits());
                response.put("quizCredits", plan.getQuizGenCredits());
            }
        }

        log.info("Payment status details: orderCode={}, status={}", orderCode, payment.getStatus());
        return response;
    }

    public List<PaymentHistoryResponse> getPaymentHistory(Long userId) {
        User user = userRepo.findById(userId)
                .orElseThrow(() -> new NotFoundException("Không tìm thấy người dùng"));

        // Limit to last 50 payments to avoid performance issues
        // For full history, implement pagination in future
        List<Payment> payments = paymentRepo.findByUserOrderByCreatedAtDesc(user);
        
        // Take only first 50 for performance
        if (payments.size() > 50) {
            log.info("User {} has {} payments, returning last 50 only", userId, payments.size());
            payments = payments.subList(0, 50);
        }

        return payments.stream()
                .map(payment -> new PaymentHistoryResponse(
                        payment.getId(),
                        payment.getPlan().getCode(),
                        payment.getPlan().getName(),
                        payment.getAmount(),
                        payment.getStatus(),
                        payment.getPaymentMethod(),
                        payment.getOrderCode() != null ? String.valueOf(payment.getOrderCode()) : null,
                        payment.getTransactionId(),
                        payment.getVnpTxnRef(),
                        payment.getVnpTransactionNo(),
                        payment.getVnpBankCode(),
                        payment.getVnpCardType(),
                        payment.getCreatedAt(),
                        payment.getPaidAt(),
                        payment.getPlan().getChatCredits(),
                        payment.getPlan().getQuizGenCredits(),
                        payment.getPlan().getDurationMonths()
                ))
                .toList();
    }

    @Transactional
    public void cancelPayment(long orderCode, Long userId) {
        Payment payment = paymentRepo.findByOrderCode(orderCode)
                .orElseThrow(() -> new NotFoundException("Không tìm thấy đơn hàng: " + orderCode));

        if (!payment.getUser().getId().equals(userId)) {
            throw new ForbiddenException("Bạn không có quyền hủy đơn hàng này");
        }

        if (!"PENDING".equals(payment.getStatus())) {
            throw new BadRequestException("Chỉ có thể hủy đơn hàng đang chờ thanh toán");
        }

        try {
            log.info("Cancelling PayOS payment: orderCode={}", orderCode);
            payOS.paymentRequests().cancel(orderCode, "Cancelled by user");
            
            payment.setStatus("CANCELLED");
            paymentRepo.save(payment);
            
            log.info("Payment cancelled successfully: orderCode={}", orderCode);
        } catch (Exception e) {
            log.error("Failed to cancel payment: orderCode={}", orderCode, e);
            throw new BadRequestException("Không thể hủy đơn hàng: " + e.getMessage());
        }
    }

    @Scheduled(fixedDelay = 900000) // Run every 15 minutes (15 * 60 * 1000)
    @Transactional
    public void cleanupStalePendingPayments() {
        log.info("Running stale payment cleanup task...");
        
        LocalDateTime staleTime = LocalDateTime.now().minusMinutes(stalePaymentMinutes);
        LocalDateTime oneDayAgo = LocalDateTime.now().minusHours(24);
        
        List<Payment> stalePayments = paymentRepo.findByStatusAndCreatedAtBefore("PENDING", staleTime);
        
        // Limit batch size to avoid rate limiting PayOS API
        if (stalePayments.size() > maxCleanupBatchSize) {
            log.info("Found {} stale payments, processing first {} only", stalePayments.size(), maxCleanupBatchSize);
            stalePayments = stalePayments.subList(0, maxCleanupBatchSize);
        }
        
        for (Payment payment : stalePayments) {
            try {
                var paymentInfo = payOS.paymentRequests().get(payment.getOrderCode());
                var status = paymentInfo.getStatus();    // PaymentLinkStatus enum
                String statusName = status != null ? status.name() : null;
                
                if ("CANCELLED".equals(statusName) || "EXPIRED".equals(statusName)) {
                    payment.setStatus("CANCELLED");
                    paymentRepo.save(payment);
                    log.info("Marked payment {} as CANCELLED", payment.getOrderCode());
                } else if ("PAID".equals(statusName)) {
                    log.warn("Found PAID payment without webhook: {}", payment.getOrderCode());
                    payment.setStatus("NEEDS_REVIEW");
                    paymentRepo.save(payment);
                }
            } catch (Exception e) {
                // Payment không tồn tại trên PayOS (có thể do credentials khác hoặc đã hết hạn)
                String errorMsg = e.getMessage() != null ? e.getMessage() : "";
                
                if (errorMsg.contains("không tồn tại") || errorMsg.contains("not found") || errorMsg.contains("tạm dừng")) {
                    // Payment link không tồn tại trên PayOS - đánh dấu EXPIRED
                    payment.setStatus("EXPIRED");
                    paymentRepo.save(payment);
                    log.info("Marked payment {} as EXPIRED (not found on PayOS)", payment.getOrderCode());
                } else if (payment.getCreatedAt().isBefore(oneDayAgo)) {
                    // Payment quá 24h và không check được - đánh dấu TIMEOUT
                    payment.setStatus("TIMEOUT");
                    paymentRepo.save(payment);
                    log.info("Marked payment {} as TIMEOUT", payment.getOrderCode());
                } else {
                    log.debug("Skipping payment {} - will retry later", payment.getOrderCode());
                }
            }
        }
        
        log.info("Stale payment cleanup completed. Processed {} payments", stalePayments.size());
    }
}
